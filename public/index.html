<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Da Vinci Code Game</title>
    <!-- Include Socket.io client library for real-time communication -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.2/socket.io.js"></script>
    <!-- Link to the external stylesheet -->
    <link rel="stylesheet" href="styles.css" />
  </head>
  <body>
    <div class="game-container">
      <!-- Lobby Screen: displayed when players are joining or waiting -->
      <div id="lobbyScreen" class="lobby-screen">
        <h1 class="lobby-title">Da Vinci Code</h1>

        <!-- Display the two player slots -->
        <div class="player-list">
          <div id="player0Slot" class="player-slot">
            <div class="player-name">Player 1</div>
            <div class="ready-status">Waiting...</div>
          </div>
          <div id="player1Slot" class="player-slot">
            <div class="player-name">Player 2</div>
            <div class="ready-status">Waiting...</div>
          </div>
        </div>

        <div id="joinControls">
          <!-- Input for player to enter their name -->
          <input
            type="text"
            id="playerNameInput"
            class="name-input"
            placeholder="Enter your name"
            maxlength="20"
          />
          <br />
          <!-- Buttons for sitting down (joining) and starting the game -->
          <button id="sitDownBtn" class="btn">Sit Down</button>
          <button id="startGameBtn" class="btn start-btn" disabled>
            Start Game
          </button>
        </div>

        <!-- Shown if the game is already in progress and a third client visits -->
        <div id="gameInProgress" class="hidden">
          <h2>Game in progress...</h2>
          <p>Please wait for the current game to finish.</p>
        </div>
      </div>

      <!-- Game Table: contains community pile, player hands, and controls -->
      <div id="gameTable" class="game-table">
        <div class="game-info">
          <!-- Text to show whose turn it is -->
          <div id="currentTurn" class="current-turn"></div>
          <!-- Text to show current phase (draw/place/guess) -->
          <div id="turnPhase" class="turn-phase"></div>
        </div>

        <!-- Community Pile: cards available for drawing -->
        <div id="communityPile" class="community-pile"></div>

        <!-- Player Hands: two divs, one for each player's hand -->
        <div id="playerHand0" class="player-hand player-0">
          <div class="player-label"></div>
        </div>
        <div id="playerHand1" class="player-hand player-1">
          <div class="player-label"></div>
        </div>

        <!-- Control Panel: Setup and in-game actions -->
        <div id="controlPanel" class="control-panel">
          <!-- Setup phase controls: selecting 4 initial cards -->
          <div id="setupControls" class="control-section hidden">
            <div class="control-title">Select 4 Cards</div>
            <div id="selectedCount" class="selected-count">Selected: 0/4</div>
            <button id="addToHandBtn" class="btn" disabled>Add to Hand</button>
          </div>
          <!-- Pre-declared container for showing drawn card -->
          <div id="drawnCardContainer" class="hidden">
            <div style="font-weight: bold; margin-bottom: 10px">Drawn Card</div>
            <div id="drawnCardDisplay" class="card"></div>
            <div id="drawnCardInstruction"></div>
            <button
              class="btn"
              id="confirmPlaceBtn"
              style="margin-top: 10px"
              disabled
            >
              Confirm Placement
            </button>
          </div>
          <!-- Game phase controls: draw, guess, end turn -->
          <div id="gameControls" class="control-section hidden">
            <div class="control-title">Actions</div>
            <!-- Instruction to click a community card to draw -->
            <div id="drawCardInstruction" class="hidden">
              Click a card from the community pile to draw it
            </div>
            <!-- Button to end the turn (shown during guess phase) -->
            <button id="endTurnBtn" class="btn hidden">End Turn</button>

            <!-- Guess controls: input for guessed value and submit -->
            <div id="guessControls" class="hidden">
              <div class="control-title">Make a Guess</div>
              <div class="guess-input">
                <input
                  type="text"
                  id="guessValueInput"
                  placeholder="Value (0-11 or -)"
                />
                <button id="submitGuessBtn" class="btn">Guess</button>
              </div>
              <div>Click on opponent's card to select it</div>
            </div>
          </div>
        </div>
      </div>

      <!-- Game Over Overlay: shown when someone wins -->
      <div id="gameOverlay" class="game-over-overlay">
        <div class="game-over-content">
          <div id="winnerText" class="winner-text"></div>
          <button id="newGameBtn" class="btn start-btn">New Game</button>
        </div>
      </div>

      <!-- Message div: shows temporary notifications -->
      <div id="messageDiv" class="message hidden"></div>
    </div>

    <script>
      // Main client class to manage UI and socket interactions
      class DaVinciCodeClient {
        constructor() {
          // Initialize Socket.io connection
          this.socket = io();
          this.myName = "";
          this.oppName = "";
          this.playerId = null;
          this.gameState = null; // getGameState() in server.js
          this.selectedCards = [];
          this.handSubmitted = false; // prevent multiple "Add to Hand"
          this.drawnCard = null; // a string of drawnCard e.g. w1fff
          this.cardPlacementPosition = null; // arrow index for placing a card into hand
          this.selectedOpponentCardIndex = -1; // index for guessing opponent card
          this.lastGuessMessage = ""; // for announcing player guess
          this.lastRevealedHand = null;
          this.lastRevealedIndex = null;

          this.hasMadeFirstCorrectGuess = false;

          // Set up event listeners on buttons and inputs
          this.initializeEventListeners();
          // Configure socket event handlers
          this.setupSocketEvents();
        }

        initializeEventListeners() {
          // Phase 1: lobby
          document
            .getElementById("sitDownBtn")
            .addEventListener("click", () => this.sitDown());
          document
            .getElementById("startGameBtn")
            .addEventListener("click", () => this.startGame());
          document
            .getElementById("playerNameInput")
            .addEventListener("keypress", (e) => {
              if (e.key === "Enter") this.updatePlayerName();
            });

          // Phase 2: setup
          document
            .getElementById("addToHandBtn")
            .addEventListener("click", () => this.addToHand());

          // Phase 3: inGame— Guess
          document
            .getElementById("submitGuessBtn")
            .addEventListener("click", () => this.submitGuess());

          document
            .getElementById("endTurnBtn")
            .addEventListener("click", () => this.endTurn());

          document
            .getElementById("guessValueInput")
            .addEventListener("input", (e) => {
              const input = e.target.value.trim();
              // Allow only 0–11 or "-"
              if (!/^(0|[1-9]|1[01]|-)$/.test(input)) {
                e.target.value = "";
              }
            });

          // Phase 4: gameOver
          document
            .getElementById("newGameBtn")
            .addEventListener("click", () => this.newGame());
        }

        setupSocketEvents() {
          // Fired when server acknowledges join
          this.socket.on("joinSuccess", (data) => {
            console.log("[DEBUG] Client received 'joinSuccess'");
            this.playerId = data.playerId;
          });

          // Whenever server sends updated lobby state
          this.socket.on("lobbyStateUpdate", (lobbyState) => {
            this.gameState = lobbyState;
            const me = lobbyState.players.find((p) => p.id === this.playerId);
            const opponent = lobbyState.players.find(
              (p) => p.id !== this.playerId,
            );

            if (me) this.myName = me.name;
            if (opponent) this.oppName = opponent.name;
            console.log("My Name:", this.myName);
            console.log("Opponent Name:", this.oppName);

            console.log("[DEBUG] Client received 'lobbyStateUpdate'");
            this.updateLobby();
          });

          // Whenever server sends updated game state
          this.socket.on("gameStateUpdate", (state) => {
            this.gameState = state;
            console.log("[DEBUG] Client socket has received 'gameStateUpdate'");
            this.updateUI();
          });

          // When both players have indicated ready and server starts game
          this.socket.on("gameStarted", () => {
            document.getElementById("setupControls").classList.remove("hidden");
            document.getElementById("gameControls").classList.add("hidden");
            this.showMessage("Game started! Select 4 cards.", 3000);
            this.updateUI();
          });

          // Transition into "playing" phase after initial setup
          this.socket.on("gamePlaying", () => {
            document.getElementById("setupControls").classList.add("hidden");
            document.getElementById("gameControls").classList.remove("hidden");
            this.showMessage("All players ready! Game begins!", 2000);
          });

          // A card was just drawn from community pile
          this.socket.on("cardDrawn", (data) => {
            console.log("[DEBUG]: cardDrawn ", data.card);
            this.drawnCard = data.card;
            // Notify player what card they drew
            // this.showMessage(`Drew ${this.formatCardValue(data.card)}`, 2000);
            // Update controls (e.g., show placement UI if in place phase)
            this.updatePlaying();
          });

          // Server responds with whether guess was correct and which card was revealed
          this.socket.on("guessResult", (data) => {
            console.log("[DEBUG] guessResult received", data);
            if (data.correct) {
              this.showMessage("Correct guess! Continue or end turn.", 3000);
              this.hasMadeFirstCorrectGuess = true; // Allow "End Turn" button
            } else {
              this.showMessage(
                "Wrong guess! Your most recent card is revealed.",
                3000,
              );
            }

            // Re-render to highlight only the last revealed card in red
            this.updateUI();
          });

          this.socket.on("lastGuess", (data) => {
            this.lastGuessMessage = `Last guess: ${data.playerName} guessed ${data.guessedValue}`;
          });

          // RIGHT AFTER the existing this.socket.on("lastGuess", ...) add:
          this.socket.on("selectOpponentCard", (data) => {
            const remoteIdx = data.cardIndex;
            // Clear any previous remote selection in our own hand (displayIdx = 0)
            const myHandElem = document.getElementById("playerHand0");
            myHandElem.querySelectorAll(".card").forEach((c) => {
              c.classList.remove("selected");
            });
            // If remoteIdx is valid, add 'selected' to that card in our hand
            if (remoteIdx != null && remoteIdx >= 0) {
              const cards = myHandElem.querySelectorAll(".card");
              if (cards[remoteIdx]) {
                cards[remoteIdx].classList.add("selected");
              }
            }
          });
          this.socket.on("guessIndex", (data) => {
            // 1) Remove any old highlight
            document.querySelectorAll(".card.last-guessed").forEach((el) => {
              el.classList.remove("last-guessed");
            });

            // 2) Figure out which hand to highlight
            const isGuesser = data.playerId === this.playerId;
            const guessedHandIdx = isGuesser ? 1 : 0;
            const guessedCardIdx = data.cardIndex;

            // Store for future renders:
            this.lastGuessedHand = guessedHandIdx;
            this.lastGuessedIndex = guessedCardIdx;

            // 3) Immediately add class to the correct DOM element
            const handElem = document.getElementById(
              `playerHand${guessedHandIdx}`,
            );
            const cards = handElem.querySelectorAll(".card");
            if (cards[guessedCardIdx]) {
              cards[guessedCardIdx].classList.add("last-guessed");
            }
          });

          // Fired when a winner is determined
          this.socket.on("gameFinished", (data) => {
            this.showGameOver(data.winner);
          });

          // Reset the client state when server resets game
          this.socket.on("gameReset", () => {
            console.log("Client received 'gameReset");
            this.resetGame();
          });
        }

        /****** Client Actions (emitting events) ******/

        isMyTurn() {
          return this.gameState.currentPlayerId === this.playerId;
        }
        updatePlayerName() {
          const name =
            document.getElementById("playerNameInput").value.trim() || null;
          this.socket.emit("updatePlayerName", { name });
        }

        sitDown() {
          // Get the entered name (or use null if empty)
          const name =
            document.getElementById("playerNameInput").value.trim() || null;
          // Tell server we're joining
          this.socket.emit("joinGame", { name });

          // Disable button immediately to prevent double-click
          document.getElementById("sitDownBtn").disabled = true;
        }

        startGame() {
          // Only enabled when two players are ready
          this.socket.emit("startGame");
        }

        addToHand() {
          // Only send initial card choices if exactly 4 selected
          if (this.selectedCards.length === 4) {
            this.socket.emit("selectInitialCards", {
              cardIndices: this.selectedCards,
            });
            // Clear local selection
            this.updateSelectedCount();
            document.getElementById("addToHandBtn").disabled = true;
            this.handSubmitted = true;
          }
        }

        selectCardFromPile(cardIndex) {
          console.log("[DEBUG] selectCardFromPile() called");
          // Emit selection request for community card at given index
          this.socket.emit("selectCardFromPile", { cardIndex });
          if (this.drawnCard) {
            // Record which communityIndex got placed (for blue highlight)
            console.log(
              "[DEBUG] drawnCard's community index: ",
              this.drawnCard.communityIndex,
            );
            this.lastPlacedCommunityIndex = this.drawnCard.communityIndex;
          }
        }

        submitGuess() {
          // Read the guess value input
          const guessValue = document.getElementById("guessValueInput").value;
          if (this.selectedOpponentCardIndex >= 0 && guessValue !== "") {
            // Convert "-" to "joker" or parse integer
            const value = guessValue === "-" ? "joker" : parseInt(guessValue);
            this.socket.emit("guessCard", {
              cardIndex: this.selectedOpponentCardIndex,
              guessedValue: value,
            });
            // Clear input and selection
            document.getElementById("guessValueInput").value = "";
            this.selectedOpponentCardIndex = -1;
            this.updateOpponentCardSelection();
          }
        }

        endTurn() {
          // Only enabled after at least one correct guess
          this.socket.emit("endTurn");
        }

        newGame() {
          this.socket.emit("newGame");
        }

        /****** UI Updates Based on gameState ******/

        updateUI() {
          console.log(
            "[DEBUG] updateUI() called in game state ",
            this.gameState,
          );
          if (!this.gameState) return;

          // Branch UI update based on current gameState property
          if (this.gameState.gameState === "lobby") {
            this.updateLobby();
          } else if (this.gameState.gameState === "setup") {
            this.updateSetup();
          } else if (this.gameState.gameState === "playing") {
            this.updatePlaying();
          }
        }

        updateLobby() {
          if (this.gameState.gameState !== "lobby") {
            console.log(
              "[ERROR] updateLobby() called while not in lobby phase, ",
              this.gameState.gameState,
            );
            return;
          }

          // Show lobby div, hide game table
          document.getElementById("lobbyScreen").style.display = "flex";
          document.getElementById("gameTable").style.display = "none";

          // Update the two slots with player names and ready statuses
          for (let i = 0; i < 2; i++) {
            const slot = document.getElementById(`player${i}Slot`);
            const nameDiv = slot.querySelector(".player-name");
            const statusDiv = slot.querySelector(".ready-status");

            if (i < this.gameState.players.length) {
              const player = this.gameState.players[i];
              // Mark “(You)” next to our own name
              const displayName =
                player.id === this.playerId
                  ? `${player.name} (You)`
                  : player.name;
              nameDiv.textContent = displayName;
              statusDiv.textContent = player.ready ? "Ready!" : "Not Ready";
              slot.classList.toggle("ready", player.ready);
            } else {
              // Slot is empty
              nameDiv.textContent = `Player ${i + 1}`;
              statusDiv.textContent = "Waiting...";
              slot.classList.remove("ready");
            }
          }

          // Enable Start Game if exactly two players and both ready
          const canStart =
            this.gameState.players.length === 2 &&
            this.gameState.players.every((p) => p.ready);
          document.getElementById("startGameBtn").disabled = !canStart;

          // If lobby is full and we haven't joined, show “Game in Progress”
          const isJoined = this.gameState.players.some(
            (p) => p.id === this.playerId,
          );

          console.log(
            "[DEBUG] players length is ",
            this.gameState.players.length,
          );
          if (this.gameState.players.length == 2 && !isJoined) {
            document.getElementById("joinControls").style.display = "none";
            document
              .getElementById("gameInProgress")
              .classList.remove("hidden");
          } else {
            // Otherwise show join controls
            document.getElementById("joinControls").style.display = "block";
            document.getElementById("gameInProgress").classList.add("hidden");
          }
        }

        updateSetup() {
          console.log("[DEBUG] updateSetup() called");
          document.querySelector(".game-info").style.display = "none";
          document.getElementById("currentTurn").style.display = "none";
          document.getElementById("turnPhase").style.display = "none";
          document.getElementById("playerHand0").style.display = "none";
          document.getElementById("playerHand1").style.display = "none";
          // Transition from lobby to setup: show game table
          this.showGameTable();
          document.getElementById("setupControls").classList.remove("hidden");

          // Hide in-game elements that shouldn't be visible yet
          document.getElementById("gameControls").classList.add("hidden");

          // document.getElementById("playerHand1").style.display = "none";

          this.renderCommunityPile();
          this.updateSelectedCount();
        }

        updatePlaying() {
          console.log(
            "[DEBUG] updatePlaying() called at phase, ",
            this.gameState.turnPhase,
          );
          // In play phase: update pile, hands, and info texts
          this.updateGameInfo();
          this.updateGameControls();
          this.renderCommunityPile();
          this.renderPlayerHands();

          // Hide setup controls, show game controls
          document.querySelector(".game-info").style.display = "block";
          document.getElementById("currentTurn").style.display = "block";
          document.getElementById("turnPhase").style.display = "block";
          document.getElementById("playerHand0").style.display = "flex";
          document.getElementById("playerHand1").style.display = "flex";
          document.getElementById("setupControls").classList.add("hidden");
          document.getElementById("gameControls").classList.remove("hidden");
        }

        showGameTable() {
          // Hide lobby, show game table div
          document.getElementById("lobbyScreen").style.display = "none";
          document.getElementById("gameTable").style.display = "block";
        }

        /****** Rendering Community Pile ******/

        renderCommunityPile() {
          // console.log("[DEBUG] renderCommunityPile() called");
          const pile = document.getElementById("communityPile");
          pile.innerHTML = ""; // Clear out existing cards

          // Setup phase: show placeholders for X community slots
          // console.log(
          //   "[DEBUG] renderCommunityPile(): gameState is ",
          //   this.gameState.gameState,
          // );
          if (this.gameState.gameState === "setup") {
            for (let i = 0; i < 24; i++) {
              const card = document.createElement("div");
              card.className = `card community-card ${
                this.selectedCards.includes(i) ? "selected" : ""
              }`;
              // Alternate background colors for visibility
              card.style.background = i % 2 === 0 ? "white" : "#333";
              card.textContent = "?";
              // Clicking toggles selection
              if (!this.handSubmitted) {
                card.addEventListener("click", () =>
                  this.toggleCardSelection(i),
                );
              }
              pile.appendChild(card);
            }
          } else {
            // Playing phase: actual communityPile data exists

            console.log("[DEBUG] Rendering community pile in playing phase");
            const pileData = this.gameState.communityPile || [];

            for (let i = 0; i < pileData.length; i++) {
              const cardData = pileData[i];

              // If already drawn, show an invisible placeholder to keep layout
              if (cardData[2] === "d") {
                const placeholder = document.createElement("div");
                placeholder.className = "card community-card";
                placeholder.style.opacity = 0;
                placeholder.style.pointerEvents = "none"; // ✅ block interaction
                placeholder.style.cursor = "default"; // ✅ prevent hover effect
                pile.appendChild(placeholder);
                continue;
              }

              const card = document.createElement("div");
              card.className = "card community-card";
              card.style.background = cardData[0] === "w" ? "white" : "#333";
              card.textContent = "?";

              // If it's our turn and in 'draw' phase, allow clicking to draw

              console.log(
                "[DEBUG] Rendering... phase is ",
                this.gameState.turnPhase,
                this.isMyTurn(),
              );
              if (this.gameState.turnPhase === "draw" && this.isMyTurn()) {
                card.style.cursor = "pointer";
                card.addEventListener("click", () =>
                  this.selectCardFromPile(i),
                );
              }
              pile.appendChild(card);
            }
          }
        }

        toggleCardSelection(cardIndex) {
          // Only allow toggling when in setup phase
          if (this.gameState.gameState !== "setup") return;

          const idx = this.selectedCards.indexOf(cardIndex);
          if (idx >= 0) {
            // Already selected: remove it
            this.selectedCards.splice(idx, 1);
          } else if (this.selectedCards.length < 4) {
            // Otherwise, add it (max 4)
            this.selectedCards.push(cardIndex);
          }

          // Re-render to reflect new selection highlight
          this.renderCommunityPile();
          this.updateSelectedCount();
        }

        updateSelectedCount() {
          const countElement = document.getElementById("selectedCount");
          if (countElement) {
            countElement.textContent = `Selected: ${
              this.selectedCards.length
            }/4`;
          }

          const addBtn = document.getElementById("addToHandBtn");
          if (addBtn) {
            // Only enable Add to Hand when exactly 4 cards picked
            addBtn.disabled = this.selectedCards.length !== 4;
          }
        }

        /****** Rendering Player Hands ******/
        renderPlayerHands() {
          console.log("[DEBUG] Rendering player Hands...");
          const hands = [this.gameState.myHand, this.gameState.oppHand];
          const playerLabels = [`${this.myName} (You)`, this.oppName];

          for (let displayIdx = 0; displayIdx < 2; displayIdx++) {
            const hand = hands[displayIdx] || [];
            const handElement = document.getElementById(
              `playerHand${displayIdx}`,
            );
            const label = handElement.querySelector(".player-label");

            // Clear existing card elements
            const cards = handElement.querySelectorAll(".card");
            cards.forEach((card) => card.remove());

            // Set label (use name if available, otherwise fallback)
            label.textContent = playerLabels[displayIdx];

            // Render each card in the hand
            hand.forEach((card, cardIdx) => {
              const cardElement = this.createCardElement(
                card,
                displayIdx, // 0 = myHand, 1 = oppHand
                cardIdx,
              );
              handElement.appendChild(cardElement);
            });
            console.log("[DEBUG] handElement contains, ", handElement);
          }
        }

        createCardElement(cardStr, displayIdx, cardIdx) {
          const cardElement = document.createElement("div");
          const color = cardStr[0]; // 'w' or 'b'
          const valueChar = cardStr[1]; // '0'-'9', 't', 'e', 'j'
          const revealedChar = cardStr[2]; // 't' or 'f'

          // 1) Base class for color
          cardElement.className = `card ${color === "w" ? "white" : "black"}`;

          // 2) Show revealed‐own / revealed‐opp or hidden‐own / hidden‐opp
          if (revealedChar !== "f") {
            displayIdx === 0
              ? cardElement.classList.add("revealed-own")
              : cardElement.classList.add("revealed-opp");
          } else {
            displayIdx === 0
              ? cardElement.classList.add("hidden-own")
              : cardElement.classList.add("hidden-opp");
          }

          // 3) Newly‐drawn flag (if cardStr[3] === 't')
          if (cardStr[3] === "t") {
            cardElement.classList.add("newly-drawn");
          }

          // 4) Re‐apply “last‐guessed” if this matches stored state
          if (
            this.lastGuessedHand === displayIdx &&
            this.lastGuessedIndex === cardIdx
          ) {
            cardElement.classList.add("last-guessed");
          }

          // 5) Now set textContent or “?” depending on hidden vs. revealed
          const isOwn = displayIdx === 0;
          const isRevealed = revealedChar === "t";
          const isHidden = !isOwn && !isRevealed;

          if (isHidden) {
            cardElement.classList.add("card-back");
            cardElement.style.background = color === "w" ? "white" : "#333";
            cardElement.style.color = color === "w" ? "#999" : "#666";
            cardElement.textContent = "?";
          } else {
            cardElement.textContent = this.formatCardValue(valueChar);
          }

          // 6) If this is an opponent’s card during guess‐phase and it’s your turn, make it clickable:
          if (
            displayIdx === 1 &&
            revealedChar == "f" &&
            this.gameState.gameState === "playing" &&
            this.gameState.turnPhase === "guess" &&
            this.isMyTurn()
          ) {
            cardElement.style.cursor = "pointer";
            cardElement.addEventListener("click", () => {
              // Toggle local selection
              this.selectedOpponentCardIndex = cardIdx;
              this.updateOpponentCardSelection();
              // Inform server so opponent sees your selection
              this.socket.emit("selectOpponentCard", { cardIndex: cardIdx });
            });
          }

          // 7) Finally, return the fully‐initialized element
          return cardElement;
        }

        formatCardValue(valueChar) {
          switch (valueChar) {
            case "j":
              return "-";
            case "t":
              return "10";
            case "v":
              return "11";
            default:
              return valueChar;
          }
        }

        updateOpponentCardSelection() {
          // The opponent's hand is always at display index 1
          const opponentDisplayIdx = 1;
          const handElement = document.getElementById(
            `playerHand${opponentDisplayIdx}`,
          );
          const cards = handElement.querySelectorAll(".card");

          cards.forEach((card, idx) => {
            // Highlight the one clicked with 'selected' class
            card.classList.toggle(
              "selected",
              idx === this.selectedOpponentCardIndex,
            );
          });
        }

        /****** Update Turn Info and Controls ******/

        updateGameInfo() {
          console.log("[DEBUG] updateGameInfo() called");
          const currentTurnElement = document.getElementById("currentTurn");
          const turnPhaseElement = document.getElementById("turnPhase");

          // Display name of current player
          if (this.gameState.currentPlayerId) {
            currentTurnElement.textContent = this.isMyTurn()
              ? "Your Turn"
              : `${this.oppName}'s Turn`;
          }

          // Map the internal phase to human-readable text
          const phaseText = {
            draw: "Draw a card",
            place: "Place the drawn card",
            guess: "Guess opponent's card",
          };
          turnPhaseElement.innerHTML =
            (this.isMyTurn() ? phaseText[this.gameState.turnPhase] : ``) +
            (this.lastGuessMessage ? `<br><br>${this.lastGuessMessage}` : "");
        }

        updateGameControls() {
          const isMyTurn = this.isMyTurn();
          const phase = this.gameState.turnPhase;

          // Show/hide “Click to Draw” instruction
          document
            .getElementById("drawCardInstruction")
            .classList.toggle("hidden", !isMyTurn || phase !== "draw");
          // Show/hide guess controls
          document
            .getElementById("guessControls")
            .classList.toggle("hidden", !isMyTurn || phase !== "guess");
          // Show/hide End Turn button
          const endBtn = document.getElementById("endTurnBtn");
          endBtn.classList.toggle("hidden", !isMyTurn || phase !== "guess");

          // Reset correct-guess flag if entering draw phase
          if (isMyTurn && phase === "draw") {
            this.hasMadeFirstCorrectGuess = false;
          }
          // During guess phase, disable End Turn until at least one correct guess
          if (isMyTurn && phase === "guess") {
            endBtn.disabled = !this.hasMadeFirstCorrectGuess;
          }

          // If a card was just drawn and now in place phase, show placement UI
          if (this.drawnCard && phase === "place") {
            this.showCardPlacementUI();
          } else {
            this.hideCardPlacementUI();
          }
        }

        /****** Card Placement (after drawing) ******/

        showCardPlacementUI() {
          const container = document.getElementById("drawnCardContainer");
          if (!container) return;

          container.classList.remove("hidden");

          const display = document.getElementById("drawnCardDisplay");
          const instruction = document.getElementById("drawnCardInstruction");

          // Update card appearance
          display.className = `card ${this.drawnCard[0] === "w" ? "white" : "black"}`;
          display.textContent = this.formatCardValue(this.drawnCard[1]);

          instruction.innerHTML =
            "Choose position with arrows, then click confirm";

          document
            .getElementById("confirmPlaceBtn")
            .addEventListener("click", () => this.confirmCardPlacement());

          this.showPlacementArrows();
        }

        showPlacementArrows() {
          document.getElementById("confirmPlaceBtn").disabled = true;
          const myHandElement = document.getElementById("playerHand0");
          // Remove any previous arrows
          const existingArrows =
            myHandElement.querySelectorAll(".placement-arrow");
          existingArrows.forEach((arrow) => arrow.remove());

          console.log("DEBUGBGGGGG ", this.gameState.myHand);
          // Compute all valid insertion indices (accounts for joker and color/value rules)
          const validPositions = this.getPossiblePlacements(
            this.drawnCard,
            this.gameState.myHand,
          );
          const handLength = this.gameState.myHand.length;

          for (let pos = 0; pos <= handLength; pos++) {
            const isValid = validPositions.includes(pos);
            this.createArrowAtPosition(myHandElement, pos, handLength, isValid);
          }

          // If there's exactly one possible spot, preselect it and enable Confirm immediately
          if (validPositions.length === 1) {
            console.log(
              "[DEBUG] card placement position = ",
              validPositions[0],
            );
            this.cardPlacementPosition = validPositions[0];
            this.updateArrowSelection();
            document.getElementById("confirmPlaceBtn").disabled = false;
          }
        }
        createArrowAtPosition(handElement, position, handLength, isValid) {
          const arrow = document.createElement("div");
          arrow.className = "placement-arrow";
          arrow.innerHTML = "▼";
          arrow.setAttribute("data-position", position);
          arrow.setAttribute("data-valid", isValid); // for later reference

          if (isValid) {
            arrow.addEventListener("click", () => {
              this.cardPlacementPosition = position;
              this.updateArrowSelection();
              document.getElementById("confirmPlaceBtn").disabled = false;
            });
            arrow.style.cursor = "pointer";
          } else {
            arrow.style.opacity = 0.3;
            arrow.style.pointerEvents = "none"; // visually disabled
          }

          // Position the arrow
          const cards = handElement.querySelectorAll(
            ".card:not(.placement-arrow)",
          );
          if (position === 0) {
            arrow.style.left = cards.length > 0 ? "-15px" : "50%";
            arrow.style.transform =
              position === 0 && cards.length === 0
                ? "translateX(-50%)"
                : "none";
          } else if (position >= handLength) {
            arrow.style.right = "-25px";
          } else {
            const cardWidth = 68;
            arrow.style.left = `${position * cardWidth - 15}px`;
          }

          handElement.appendChild(arrow);
        }

        updateArrowSelection() {
          const arrows = document.querySelectorAll(".placement-arrow");
          arrows.forEach((arrow) => {
            const pos = parseInt(arrow.getAttribute("data-position"), 10);
            const isValid = arrow.getAttribute("data-valid") === "true";
            const isSelected = pos === this.cardPlacementPosition;
            const isOnlyValid = arrows.length === 1;

            if (isValid) {
              arrow.style.color =
                isSelected || isOnlyValid ? "#ff4444" : "#ffd700";
              arrow.style.fontSize =
                isSelected || isOnlyValid ? "24px" : "20px";
            } else {
              arrow.style.color = "#999999";
              arrow.style.fontSize = "18px";
            }
          });
        }

        hideCardPlacementUI() {
          const container = document.getElementById("drawnCardContainer");
          if (container) {
            container.classList.add("hidden");
          }

          const arrows = document.querySelectorAll(".placement-arrow");
          arrows.forEach((arrow) => arrow.remove());

          this.cardPlacementPosition = null;
        }

        /****** Logic for Determining Valid Placements ******/

        getPossiblePlacements(card, currentHand) {
          const placements = [];

          // Joker to place? Can go anywhere
          if (card[1] === "j") {
            for (let i = 0; i <= currentHand.length; i++) {
              placements.push(i);
            }
            return placements;
          }

          for (let i = 0; i <= currentHand.length; i++) {
            const left = getNonJokerLeft(currentHand, i - 1);
            const right = getNonJokerRight(currentHand, i);

            const canPlaceLeft = !left || isValidLeftNeighbor(left, card);
            const canPlaceRight = !right || isValidRightNeighbor(card, right);

            if (canPlaceLeft && canPlaceRight) {
              placements.push(i);
            }
          }

          return placements;

          // Skip jokers to the left
          function getNonJokerLeft(hand, i) {
            while (i >= 0 && hand[i][1] === "j") i--;
            return hand[i] || null;
          }

          // Skip jokers to the right
          function getNonJokerRight(hand, i) {
            while (i < hand.length && hand[i][1] === "j") i++;
            return hand[i] || null;
          }

          function isValidLeftNeighbor(leftCard, newCard) {
            if (leftCard[1] < newCard[1]) return true;
            if (leftCard[1] === newCard[1]) {
              return leftCard[0] < newCard[0]; // b < w
            }
            return false;
          }

          function isValidRightNeighbor(newCard, rightCard) {
            if (newCard[1] < rightCard[1]) return true;
            if (newCard[1] === rightCard[1]) {
              return newCard[0] < rightCard[0]; // b < w
            }
            return false;
          }
        }

        confirmCardPlacement() {
          if (this.drawnCard) {
            // Emit placement event with chosen position
            console.log(
              "Sending 'placeCard' with position, ",
              this.cardPlacementPosition,
            );
            this.socket.emit("placeCard", {
              card: this.drawnCard,
              position: this.cardPlacementPosition,
            });

            // Clear drawnCard and hide placement UI
            this.drawnCard = null;
            this.hideCardPlacementUI();
          }
        }

        /****** Game Over and Messaging ******/

        showGameOver(winner) {
          // Display overlay with winner message
          document.getElementById("winnerText").textContent = `${winner} wins!`;
          document.getElementById("gameOverlay").style.display = "flex";
        }

        showMessage(message, duration = 3000) {
          // Temporarily show a message div at bottom
          const messageDiv = document.getElementById("messageDiv");
          messageDiv.textContent = message;
          messageDiv.classList.remove("hidden");

          setTimeout(() => {
            messageDiv.classList.add("hidden");
          }, duration);
        }

        resetGame() {
          // Reset lobby
          document.getElementById("sitDownBtn").disabled = false;
          this.oppName = "";
          this.gameState = null; // getGameState() in server.js
          this.selectedCards = [];
          // Reset setup
          this.handSubmitted = false;
          // Reset local state and return to lobby screen
          this.selectedCards = [];
          this.drawnCard = null;
          this.cardPlacementPosition = null;
          this.selectedOpponentCardIndex = -1;
          this.hasMadeFirstCorrectGuess = false;

          this.lastGuessMessage = "";
          this.lastRevealedHand = null;
          this.lastRevealedIndex = null;

          document.getElementById("gameOverlay").style.display = "none";
          document.getElementById("lobbyScreen").style.display = "flex";
          document.getElementById("gameTable").style.display = "none";
        }
      }

      // Instantiate the game client when page loads
      const gameClient = new DaVinciCodeClient();
    </script>
  </body>
</html>
