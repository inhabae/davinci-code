<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Da Vinci Code Game</title>
    <!-- Include Socket.io client library for real-time communication -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.2/socket.io.js"></script>
    <!-- Link to the external stylesheet -->
    <link rel="stylesheet" href="styles.css" />
  </head>
  <body>
    <div class="game-container">
      <!-- Lobby Screen: displayed when players are joining or waiting -->
      <div id="lobbyScreen" class="lobby-screen">
        <h1 class="lobby-title">Da Vinci Code</h1>

        <!-- Display the two player slots -->
        <div class="player-list">
          <div id="player0Slot" class="player-slot">
            <div class="player-name">Player 1</div>
            <div class="ready-status">Waiting...</div>
          </div>
          <div id="player1Slot" class="player-slot">
            <div class="player-name">Player 2</div>
            <div class="ready-status">Waiting...</div>
          </div>
        </div>

        <div id="joinControls">
          <!-- Input for player to enter their name -->
          <input
            type="text"
            id="playerNameInput"
            class="name-input"
            placeholder="Enter your name"
            maxlength="20"
          />
          <br />
          <!-- Buttons for sitting down (joining) and starting the game -->
          <button id="sitDownBtn" class="btn">Sit Down</button>
          <button id="startGameBtn" class="btn start-btn" disabled>
            Start Game
          </button>
        </div>

        <!-- Shown if the game is already in progress and a third client visits -->
        <div id="gameInProgress" class="hidden">
          <h2>Game in progress...</h2>
          <p>Please wait for the current game to finish.</p>
        </div>
      </div>

      <!-- Game Table: contains community pile, player hands, and controls -->
      <div id="gameTable" class="game-table">
        <div class="game-info">
          <!-- Text to show whose turn it is -->
          <div id="currentTurn" class="current-turn"></div>
          <!-- Text to show current phase (draw/place/guess) -->
          <div id="turnPhase" class="turn-phase"></div>
        </div>

        <!-- Community Pile: cards available for drawing -->
        <div id="communityPile" class="community-pile"></div>

        <!-- Player Hands: two divs, one for each player's hand -->
        <div id="playerHand0" class="player-hand player-0">
          <div class="player-label"></div>
        </div>
        <div id="playerHand1" class="player-hand player-1">
          <div class="player-label"></div>
        </div>

        <!-- Control Panel: Setup and in-game actions -->
        <div id="controlPanel" class="control-panel">
          <!-- Setup phase controls: selecting 4 initial cards -->
          <div id="setupControls" class="control-section hidden">
            <div class="control-title">Select 4 Cards</div>
            <div id="selectedCount" class="selected-count">Selected: 0/4</div>
            <button id="addToHandBtn" class="btn" disabled>Add to Hand</button>
          </div>

          <!-- Game phase controls: draw, guess, end turn -->
          <div id="gameControls" class="control-section hidden">
            <div class="control-title">Actions</div>
            <!-- Instruction to click a community card to draw -->
            <div id="drawCardInstruction" class="hidden">
              Click a card from the community pile to draw it
            </div>
            <!-- Button to end the turn (shown during guess phase) -->
            <button id="endTurnBtn" class="btn hidden">End Turn</button>

            <!-- Guess controls: input for guessed value and submit -->
            <div id="guessControls" class="hidden">
              <div class="control-title">Make a Guess</div>
              <div class="guess-input">
                <input
                  type="text"
                  id="guessValueInput"
                  placeholder="Value (0-11 or - for joker)"
                />
                <button id="submitGuessBtn" class="btn">Guess</button>
              </div>
              <div>Click on opponent's card to select it</div>
            </div>
          </div>
        </div>
      </div>

      <!-- Game Over Overlay: shown when someone wins -->
      <div id="gameOverlay" class="game-over-overlay">
        <div class="game-over-content">
          <div id="winnerText" class="winner-text"></div>
          <button id="newGameBtn" class="btn start-btn">New Game</button>
        </div>
      </div>

      <!-- Message div: shows temporary notifications -->
      <div id="messageDiv" class="message hidden"></div>
    </div>

    <script>
      // Main client class to manage UI and socket interactions
      class DaVinciCodeClient {
        constructor() {
          // Initialize Socket.io connection
          this.socket = io();
          this.playerId = null; // Unique ID assigned by server
          this.playerIndex = -1; // 0 or 1 once joined
          this.gameState = null; // Current game state
          this.selectedCards = []; // For setup: indices of chosen cards
          this.drawnCard = null; // The card just drawn from community
          this.selectedOpponentCard = -1; // Index of opponent's card during guess

          // Track communityIndex values for highlighting the latest placed/revealed cards
          this.lastPlacedCommunityIndex = null;
          this.lastRevealedCommunityIndex = null;

          // State to enforce that at least one correct guess must happen before ending turn
          this.hasMadeFirstCorrectGuess = false;

          // Set up event listeners on buttons and inputs
          this.initializeEventListeners();
          // Configure socket event handlers
          this.setupSocketEvents();
        }

        initializeEventListeners() {
          // Lobby: Sit Down button
          document
            .getElementById("sitDownBtn")
            .addEventListener("click", () => this.sitDown());
          // Lobby: Start Game button
          document
            .getElementById("startGameBtn")
            .addEventListener("click", () => this.startGame());
          // Allow pressing Enter in name input to sit down
          document
            .getElementById("playerNameInput")
            .addEventListener("keypress", (e) => {
              if (e.key === "Enter") this.sitDown();
            });

          // Setup phase: Add to Hand button
          document
            .getElementById("addToHandBtn")
            .addEventListener("click", () => this.addToHand());
          // Guess phase: Submit Guess button
          document
            .getElementById("submitGuessBtn")
            .addEventListener("click", () => this.submitGuess());
          // Guess phase: End Turn button
          document
            .getElementById("endTurnBtn")
            .addEventListener("click", () => this.endTurn());
          // Game Over: New Game button
          document
            .getElementById("newGameBtn")
            .addEventListener("click", () => this.newGame());

          // Validate guess input to ensure only valid numbers or "-" for joker
          document
            .getElementById("guessValueInput")
            .addEventListener("input", (e) => {
              const value = parseInt(e.target.value);
              if (value < 0 || value > 11) {
                e.target.value = "";
              }
            });
        }

        setupSocketEvents() {
          // Fired when server acknowledges join
          this.socket.on("joinSuccess", (data) => {
            console.log("[DEBUG] Client socket has received 'joinSuccess'");
            this.playerId = data.playerId;
            this.showMessage("Joined game successfully!", 3000);
          });

          // Fired if join fails (e.g., already two players)
          this.socket.on("joinFailed", (data) => {
            console.log("[DEBUG] Client socket has received 'joinFailed'");
            this.showMessage(data.message, 3000);
          });

          // Whenever server sends updated game state
          this.socket.on("gameStateUpdate", (state) => {
            console.log("[DEBUG] Client socket has received 'gameStateUpdate'");
            console.log(state);
            this.gameState = state;
            this.updateUI();
          });

          // When both players have indicated ready and server starts game
          this.socket.on("gameStarted", () => {
            this.showGameTable();
            this.showMessage("Game started! Select 4 cards.", 3000);
          });

          // Transition into "playing" phase after initial setup
          this.socket.on("gamePlaying", () => {
            this.showMessage("All players ready! Game begins!", 2000);
          });

          // A card was just drawn from community pile
          this.socket.on("cardDrawn", (data) => {
            console.log("[DEBUG]: cardDrawn has been received by the client.");
            this.drawnCard = data.card;
            // Notify player what card they drew
            this.showMessage(`Drew ${this.formatCardValue(data.card)}`, 2000);
            // Update controls (e.g., show placement UI if in place phase)
            this.updateGameControls();
          });

          // Server responds with whether guess was correct and which card was revealed
          this.socket.on("guessResult", (data) => {
            // Store the communityIndex of the card just revealed
            this.lastRevealedCommunityIndex = data.revealedCommunityIndex;

            if (data.correct) {
              this.showMessage("Correct guess! Continue or end turn.", 3000);
              this.hasMadeFirstCorrectGuess = true; // Allow "End Turn" button
            } else {
              this.showMessage(
                "Wrong guess! Your most recent card is revealed.",
                3000,
              );
            }

            // Re-render to highlight only the last revealed card in red
            this.updateGameControls();
            this.updateUI();
          });

          // Fired when a winner is determined
          this.socket.on("gameFinished", (data) => {
            this.showGameOver(data.winner);
          });

          // Reset the client state when server resets game
          this.socket.on("gameReset", () => {
            this.resetGame();
          });
        }

        /****** Client Actions (emitting events) ******/

        sitDown() {
          // Get the entered name (or use null if empty)
          const name =
            document.getElementById("playerNameInput").value.trim() || null;
          // Tell server we're joining
          this.socket.emit("joinGame", { name });

          // Disable button immediately to prevent double-click
          document.getElementById("sitDownBtn").disabled = true;
        }

        startGame() {
          // Only enabled when two players are ready
          this.socket.emit("startGame");
        }

        addToHand() {
          // Only send initial card choices if exactly 4 selected
          if (this.selectedCards.length === 4) {
            this.socket.emit("selectInitialCards", {
              cardIndices: this.selectedCards,
            });
            // Clear local selection
            this.selectedCards = [];
            this.updateSelectedCount();
          }
        }

        selectCardFromPile(cardIndex) {
          // Emit selection request for community card at given index
          this.socket.emit("selectCardFromPile", { cardIndex });
          if (this.drawnCard) {
            // Record which communityIndex got placed (for blue highlight)
            console.log(
              "[DEBUG] drawnCard's community index: ",
              this.drawnCard.communityIndex,
            );
            this.lastPlacedCommunityIndex = this.drawnCard.communityIndex;
          }
        }

        submitGuess() {
          // Read the guess value input
          const guessValue = document.getElementById("guessValueInput").value;
          if (this.selectedOpponentCard >= 0 && guessValue !== "") {
            // Convert "-" to "joker" or parse integer
            const value = guessValue === "-" ? "joker" : parseInt(guessValue);
            this.socket.emit("guessCard", {
              cardIndex: this.selectedOpponentCard,
              guessedValue: value,
            });
            // Clear input and selection
            document.getElementById("guessValueInput").value = "";
            this.selectedOpponentCard = -1;
            this.updateOpponentCardSelection();
          }
        }

        endTurn() {
          // Only enabled after at least one correct guess
          this.socket.emit("endTurn");
        }

        newGame() {
          this.socket.emit("newGame");
        }

        /****** UI Updates Based on gameState ******/

        updateUI() {
          if (!this.gameState) return;

          // Determine our playerIndex within the players array
          if (this.gameState.players.length > 0) {
            this.playerIndex = this.gameState.players.findIndex(
              (p) => p.id === this.playerId,
            );
          }

          // Branch UI update based on current gameState property
          if (this.gameState.gameState === "lobby") {
            this.updateLobby();
          } else if (this.gameState.gameState === "setup") {
            this.updateSetup();
          } else if (this.gameState.gameState === "playing") {
            this.updatePlaying();
          }
        }

        updateLobby() {
          // Show lobby div, hide game table
          document.getElementById("lobbyScreen").style.display = "flex";
          document.getElementById("gameTable").style.display = "none";

          // Update the two slots with player names and ready statuses
          for (let i = 0; i < 2; i++) {
            const slot = document.getElementById(`player${i}Slot`);
            const nameDiv = slot.querySelector(".player-name");
            const statusDiv = slot.querySelector(".ready-status");

            if (i < this.gameState.players.length) {
              const player = this.gameState.players[i];
              // Mark “(You)” next to our own name
              const displayName =
                player.id === this.playerId
                  ? `${player.name} (You)`
                  : player.name;
              nameDiv.textContent = displayName;
              statusDiv.textContent = player.ready ? "Ready!" : "Not Ready";
              slot.classList.toggle("ready", player.ready);
            } else {
              // Slot is empty
              nameDiv.textContent = `Player ${i + 1}`;
              statusDiv.textContent = "Waiting...";
              slot.classList.remove("ready");
            }
          }

          // Enable Start Game if exactly two players and both ready
          const canStart =
            this.gameState.players.length === 2 &&
            this.gameState.players.every((p) => p.ready);
          document.getElementById("startGameBtn").disabled = !canStart;

          // If lobby is full and we haven't joined, show “Game in Progress”
          const isJoined = this.gameState.players.some(
            (p) => p.id === this.playerId,
          );
          if (this.gameState.players.length >= 2 && !isJoined) {
            document.getElementById("joinControls").style.display = "none";
            document
              .getElementById("gameInProgress")
              .classList.remove("hidden");
          } else {
            // Otherwise show join controls
            document.getElementById("joinControls").style.display = "block";
            document.getElementById("gameInProgress").classList.add("hidden");
          }
        }

        updateSetup() {
          // Transition from lobby to setup: show game table
          this.showGameTable();
          // Render community pile and player hands (empty initially)
          this.renderCommunityPile();
          this.renderPlayerHands();

          // Show selection controls, hide game controls
          document.getElementById("setupControls").classList.remove("hidden");
          document.getElementById("gameControls").classList.add("hidden");

          // Update the “Selected: x/4” counter
          this.updateSelectedCount();
        }

        updatePlaying() {
          // In play phase: update pile, hands, and info texts
          this.renderCommunityPile();
          this.renderPlayerHands();
          this.updateGameInfo();
          this.updateGameControls();

          // Hide setup controls, show game controls
          document.getElementById("setupControls").classList.add("hidden");
          document.getElementById("gameControls").classList.remove("hidden");
        }

        showGameTable() {
          // Hide lobby, show game table div
          document.getElementById("lobbyScreen").style.display = "none";
          document.getElementById("gameTable").style.display = "block";
        }

        /****** Rendering Community Pile ******/

        renderCommunityPile() {
          const pile = document.getElementById("communityPile");
          pile.innerHTML = ""; // Clear out existing cards

          // Setup phase: show placeholders for X community slots
          if (this.gameState.gameState === "setup") {
            for (let i = 0; i < this.gameState.communityPileSize; i++) {
              const card = document.createElement("div");
              card.className = `card community-card ${
                this.selectedCards.includes(i) ? "selected" : ""
              }`;
              // Alternate background colors for visibility
              card.style.background = i % 2 === 0 ? "white" : "#333";
              card.textContent = "?";
              // Clicking toggles selection
              card.addEventListener("click", () => this.toggleCardSelection(i));
              pile.appendChild(card);
            }
          } else {
            // Playing phase: actual communityPile data exists
            const pileData = this.gameState.communityPile || [];

            for (let i = 0; i < pileData.length; i++) {
              const cardData = pileData[i];

              // If already drawn, show an invisible placeholder to keep layout
              if (cardData.drawn) {
                const placeholder = document.createElement("div");
                placeholder.className = "card community-card";
                placeholder.style.opacity = 0;
                pile.appendChild(placeholder);
                continue;
              }

              const card = document.createElement("div");
              card.className = "card community-card";
              card.style.background =
                cardData.color === "white" ? "white" : "#333";
              card.textContent = "?";

              // If it's our turn and in 'draw' phase, allow clicking to draw
              if (
                this.gameState.turnPhase === "draw" &&
                this.playerIndex === this.gameState.currentPlayer
              ) {
                card.style.cursor = "pointer";
                card.addEventListener("click", () =>
                  this.selectCardFromPile(i),
                );
              }

              pile.appendChild(card);
            }
          }
        }

        toggleCardSelection(cardIndex) {
          // Only allow toggling when in setup phase
          if (this.gameState.gameState !== "setup") return;

          const idx = this.selectedCards.indexOf(cardIndex);
          if (idx >= 0) {
            // Already selected: remove it
            this.selectedCards.splice(idx, 1);
          } else if (this.selectedCards.length < 4) {
            // Otherwise, add it (max 4)
            this.selectedCards.push(cardIndex);
          }

          // Re-render to reflect new selection highlight
          this.renderCommunityPile();
          this.updateSelectedCount();
        }

        updateSelectedCount() {
          const countElement = document.getElementById("selectedCount");
          if (countElement) {
            countElement.textContent = `Selected: ${
              this.selectedCards.length
            }/4`;
          }

          const addBtn = document.getElementById("addToHandBtn");
          if (addBtn) {
            // Only enable Add to Hand when exactly 4 cards picked
            addBtn.disabled = this.selectedCards.length !== 4;
          }
        }

        /****** Rendering Player Hands ******/

        renderPlayerHands() {
          // Always display current player on bottom (display index 0)
          const displayOrder = [this.playerIndex, 1 - this.playerIndex];

          for (let displayIdx = 0; displayIdx < 2; displayIdx++) {
            const actualPlayerIdx = displayOrder[displayIdx];
            const handElement = document.getElementById(
              `playerHand${displayIdx}`,
            );
            const label = handElement.querySelector(".player-label");

            // Clear existing card elements
            const cards = handElement.querySelectorAll(".card");
            cards.forEach((card) => card.remove());

            // Set the label to player name
            if (this.gameState.players[actualPlayerIdx]) {
              const player = this.gameState.players[actualPlayerIdx];
              const displayName =
                player.id === this.playerId
                  ? `${player.name} (You)`
                  : player.name;
              label.textContent = displayName;
            }

            // Render each card in that player's hand
            const hand = this.gameState.playerHands[actualPlayerIdx] || [];
            hand.forEach((card, cardIdx) => {
              const cardElement = this.createCardElement(
                card,
                actualPlayerIdx,
                cardIdx,
              );
              handElement.appendChild(cardElement);
            });
          }
        }

        createCardElement(card, actualPlayerIdx, cardIdx) {
          const cardElement = document.createElement("div");
          // Base classes: .card and color (white/black)
          cardElement.className = `card ${card.color}`;
          // If this card was the last placed to hand, add 'newly-drawn' class
          if (card.communityIndex === this.lastPlacedCommunityIndex) {
            cardElement.classList.add("newly-drawn");
            console.log("[DEBUG]: Added newly-drawn.");
          }

          // Determine if this card belongs to us
          const isOwn =
            this.gameState.players[actualPlayerIdx]?.id === this.playerId;
          const isRevealed = card.revealed;
          const isHidden = !isOwn && !isRevealed;

          if (isHidden) {
            // Show card back when not ours and not yet revealed
            cardElement.classList.add("card-back");
            cardElement.style.background =
              card.color === "white" ? "white" : "#333";
            cardElement.style.color = card.color === "white" ? "#999" : "#666";
            cardElement.textContent = "?";
          } else {
            // If face-up (ours or revealed), show actual value
            cardElement.textContent = this.formatCardValue(card);
          }

          if (isRevealed) {
            // If revealed, highlight only if it matches lastRevealedCommunityIndex
            if (card.communityIndex === this.lastRevealedCommunityIndex) {
              cardElement.classList.add("last-revealed");
            }
          } else if (
            !isOwn &&
            !isRevealed &&
            this.gameState.gameState === "playing" &&
            this.gameState.turnPhase === "guess" &&
            this.playerIndex === this.gameState.currentPlayer
          ) {
            // During guess phase on our turn: allow clicking opponent's card
            cardElement.style.cursor = "pointer";

            cardElement.addEventListener("click", () => {
              this.selectedOpponentCard = cardIdx;
              this.selectedOpponentActualIndex = actualPlayerIdx;
              this.updateOpponentCardSelection();
            });
          }

          return cardElement;
        }

        updateOpponentCardSelection() {
          // The opponent's hand is always at display index 1
          const opponentDisplayIdx = 1;
          const handElement = document.getElementById(
            `playerHand${opponentDisplayIdx}`,
          );
          const cards = handElement.querySelectorAll(".card");

          cards.forEach((card, idx) => {
            // Highlight the one clicked with 'selected' class
            card.classList.toggle(
              "selected",
              idx === this.selectedOpponentCard,
            );

            // Debug: print out communityIndex values for debugging
            console.log(card.communityIndex, this.lastPlacedCommunityIndex);
            if (card.communityIndex === this.lastPlacedCommunityIndex) {
              // We want to outline the latest placed card with the 'newly-drawn' class,
              // but this belongs in createCardElement. If needed, handle in CSS.
            }
          });
        }

        formatCardValue(card) {
          // Show '-' for joker, otherwise numeric value
          return card.value === "joker" ? "-" : card.value.toString();
        }

        /****** Update Turn Info and Controls ******/

        updateGameInfo() {
          const currentTurnElement = document.getElementById("currentTurn");
          const turnPhaseElement = document.getElementById("turnPhase");

          // Display name of current player
          if (this.gameState.players[this.gameState.currentPlayer]) {
            const currentPlayer =
              this.gameState.players[this.gameState.currentPlayer];
            const isYourTurn = currentPlayer.id === this.playerId;
            currentTurnElement.textContent = isYourTurn
              ? "Your Turn"
              : `${currentPlayer.name}'s Turn`;
          }

          // Map the internal phase to human-readable text
          const phaseText = {
            draw: "Draw a card",
            place: "Place the drawn card",
            guess: "Guess opponent's card",
          };
          turnPhaseElement.textContent =
            phaseText[this.gameState.turnPhase] || "";
        }

        updateGameControls() {
          const isMyTurn = this.playerIndex === this.gameState.currentPlayer;
          const phase = this.gameState.turnPhase;

          // Show/hide “Click to Draw” instruction
          document
            .getElementById("drawCardInstruction")
            .classList.toggle("hidden", !isMyTurn || phase !== "draw");
          // Show/hide guess controls
          document
            .getElementById("guessControls")
            .classList.toggle("hidden", !isMyTurn || phase !== "guess");
          // Show/hide End Turn button
          const endBtn = document.getElementById("endTurnBtn");
          endBtn.classList.toggle("hidden", !isMyTurn || phase !== "guess");

          // Reset correct-guess flag if entering draw phase
          if (isMyTurn && phase === "draw") {
            this.hasMadeFirstCorrectGuess = false;
          }
          // During guess phase, disable End Turn until at least one correct guess
          if (isMyTurn && phase === "guess") {
            endBtn.disabled = !this.hasMadeFirstCorrectGuess;
          }

          // If a card was just drawn and now in place phase, show placement UI
          if (this.drawnCard && phase === "place") {
            this.showCardPlacementUI();
          } else {
            this.hideCardPlacementUI();
          }
        }

        /****** Card Placement (after drawing) ******/

        showCardPlacementUI() {
          // If UI container already exists, skip
          if (document.getElementById("drawnCardContainer")) return;

          // Create a container in control panel for showing drawn card
          const controlPanel = document.getElementById("controlPanel");
          const container = document.createElement("div");
          container.id = "drawnCardContainer";
          container.style.cssText = `
            margin-bottom: 15px;
            padding: 15px;
            border: 2px solid #ffd700;
            border-radius: 10px;
            background: rgba(255, 215, 0, 0.1);
            text-align: center;
          `;

          // Check if drawn card is a joker
          const currentHand =
            this.gameState.playerHands[this.playerIndex] || [];
          const isJoker = this.drawnCard.value === "joker";
          if (!this.cardPlacementPosition) {
            // For non-joker, precompute correct sorted position
            if (!isJoker) {
              this.cardPlacementPosition = this.getFixedPosition(
                this.drawnCard,
                currentHand,
              );
            } else {
              this.cardPlacementPosition = null;
            }
          }

          // Build inner HTML to show drawn card and instructions
          container.innerHTML = `
            <div style="font-weight: bold; margin-bottom: 10px;">Drawn Card</div>
            <div class="card ${this.drawnCard.color}" style="display: inline-block;">
              ${this.formatCardValue(this.drawnCard)}
            </div>
            ${
              isJoker
                ? `<div>Choose position with arrows, then click confirm</div>`
                : `<div>Card will be placed in correct position</div>`
            }
            <!-- Confirm starts disabled; will be enabled when arrow clicked -->
            <button class="btn" id="confirmPlaceBtn" style="margin-top: 10px;" disabled>Confirm Placement</button>
          `;

          // Insert container at top of control panel
          controlPanel.insertBefore(container, controlPanel.firstChild);

          // Listen for confirm placement click
          document
            .getElementById("confirmPlaceBtn")
            .addEventListener("click", () => this.confirmCardPlacement());

          // Show placement arrows on hand
          this.showPlacementArrows();
        }

        showPlacementArrows() {
          const myHandElement = document.getElementById("playerHand0");
          const currentHand =
            this.gameState.playerHands[this.playerIndex] || [];

          // Remove any previous arrows
          const existingArrows =
            myHandElement.querySelectorAll(".placement-arrow");
          existingArrows.forEach((arrow) => arrow.remove());

          // Compute all valid insertion indices (accounts for joker and color/value rules)
          const positions = this.getPossiblePlacements(
            this.drawnCard,
            currentHand,
          );
          // Create an arrow at each valid position
          positions.forEach((pos) => {
            this.createArrowAtPosition(myHandElement, pos, currentHand.length);
          });

          // If there's exactly one possible spot, preselect it and enable Confirm immediately
          if (positions.length === 1) {
            this.cardPlacementPosition = positions[0];
            this.updateArrowSelection();
            document.getElementById("confirmPlaceBtn").disabled = false;
          }
        }

        createArrowAtPosition(handElement, position, handLength) {
          const arrow = document.createElement("div");
          arrow.className = "placement-arrow";
          arrow.innerHTML = "▼"; // Downward arrow icon
          arrow.style.cssText = `
            position: absolute;
            top: -20px;
            font-size: 20px;
            color: gold;
            z-index: 30;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            cursor: pointer;
          `;

          // Clicking an arrow selects that placement
          arrow.addEventListener("click", () => {
            this.cardPlacementPosition = position;
            this.updateArrowSelection();
            document.getElementById("confirmPlaceBtn").disabled = false;
          });

          // Position the arrow above the correct slot in the hand
          const cards = handElement.querySelectorAll(
            ".card:not(.placement-arrow)",
          );
          if (position === 0) {
            arrow.style.left = cards.length > 0 ? "-15px" : "50%";
            arrow.style.transform =
              position === 0 && cards.length === 0
                ? "translateX(-50%)"
                : "none";
          } else if (position >= handLength) {
            const lastCard = cards[cards.length - 1];
            arrow.style.right = "-25px";
          } else {
            const cardWidth = 68; // assumption: card width + margin
            arrow.style.left = `${position * cardWidth - 15}px`;
          }

          handElement.appendChild(arrow);
        }

        updateArrowSelection() {
          // Highlight the selected arrow in red and enlarge it slightly
          const arrows = document.querySelectorAll(".placement-arrow");
          arrows.forEach((arrow, index) => {
            arrow.style.color =
              index === this.cardPlacementPosition ? "#ff4444" : "#ffd700";
            arrow.style.fontSize =
              index === this.cardPlacementPosition ? "24px" : "20px";
          });
        }

        hideCardPlacementUI() {
          // Remove the drawn card container and any arrows/indicators
          const container = document.getElementById("drawnCardContainer");
          if (container) {
            container.remove();
          }
          const arrows = document.querySelectorAll(".placement-arrow");
          arrows.forEach((arrow) => arrow.remove());
          this.cardPlacementPosition = null;
        }

        /****** Logic for Determining Valid Placements ******/

        getPossiblePlacements(card, currentHand) {
          const placements = [];
          const isJokerCard = card.value === "joker";

          // If drawn card is Joker → it can go anywhere
          if (isJokerCard) {
            for (let i = 0; i <= currentHand.length; i++) {
              placements.push(i);
            }
            return placements;
          }

          // For non-joker, find valid insertion slots based on numeric value and color rules
          for (let i = 0; i <= currentHand.length; i++) {
            // Case A: placing at front (i === 0)
            if (i === 0) {
              const rightCard = currentHand[0];
              // Conditions to place at front:
              //   a) right neighbor is a joker
              //   b) drawn.value < right.value
              //   c) drawn.value == right.value AND drawn is black & right is white
              if (
                rightCard.value === "joker" ||
                card.value < rightCard.value ||
                (card.value === rightCard.value &&
                  card.color === "black" &&
                  rightCard.color === "white")
              ) {
                placements.push(i);
              }
              continue;
            }

            // Case B: placing at end (i === hand.length)
            if (i === currentHand.length) {
              const leftCard = currentHand[i - 1];
              // Conditions to place at end:
              //   a) left neighbor is a joker
              //   b) drawn.value > left.value
              //   c) drawn.value == left.value AND drawn is white & left is black
              if (
                leftCard.value === "joker" ||
                card.value > leftCard.value ||
                (card.value === leftCard.value &&
                  card.color === "white" &&
                  leftCard.color === "black")
              ) {
                placements.push(i);
              }
              continue;
            }

            // Case C: placing in the middle (0 < i < hand.length)
            const leftCard = currentHand[i - 1];
            const rightCard = currentHand[i];
            const leftIsJoker = leftCard.value === "joker";
            const rightIsJoker = rightCard.value === "joker";

            // a) If either neighbor is a joker, can place between them
            if (leftIsJoker || rightIsJoker) {
              placements.push(i);
              continue;
            }

            const leftVal = leftCard.value;
            const rightVal = rightCard.value;

            // b) If drawn value strictly between neighbors
            if (card.value > leftVal && card.value < rightVal) {
              placements.push(i);
              continue;
            }

            // c) If drawn.value == leftVal: allow if drawn is black & left is white
            if (
              card.value === leftVal &&
              card.color === "black" &&
              leftCard.color === "white"
            ) {
              placements.push(i);
              continue;
            }

            // d) If drawn.value == rightVal: allow if drawn is white & right is black
            if (
              card.value === rightVal &&
              card.color === "white" &&
              rightCard.color === "black"
            ) {
              placements.push(i);
              continue;
            }
          }

          // Return sorted, unique placements
          return Array.from(new Set(placements)).sort((a, b) => a - b);
        }

        getFixedPosition(card, currentHand) {
          // Finds the correct sorted insertion index for a non-joker card
          let position = 0;
          for (const handCard of currentHand) {
            if (handCard.value === "joker") continue;

            // If drawn should come before handCard, break
            if (
              card.value < handCard.value ||
              (card.value === handCard.value &&
                card.color === "black" &&
                handCard.color === "white")
            ) {
              break;
            }
            position++;
          }
          return position;
        }

        confirmCardPlacement() {
          if (this.drawnCard) {
            // Mark communityIndex of placed card (blue highlight)
            this.lastPlacedCommunityIndex = this.drawnCard.communityIndex;
            // Emit placement event with chosen position
            this.socket.emit("placeCard", {
              card: this.drawnCard,
              position: this.cardPlacementPosition,
              lpc: this.lastPlacedCommunityIndex,
            });

            // Clear drawnCard and hide placement UI
            this.drawnCard = null;
            this.hideCardPlacementUI();
            this.updateUI();
          }
        }

        /****** Game Over and Messaging ******/

        showGameOver(winner) {
          // Display overlay with winner message
          document.getElementById("winnerText").textContent = `${winner} wins!`;
          document.getElementById("gameOverlay").style.display = "flex";
        }

        showMessage(message, duration = 3000) {
          // Temporarily show a message div at bottom
          const messageDiv = document.getElementById("messageDiv");
          messageDiv.textContent = message;
          messageDiv.classList.remove("hidden");

          setTimeout(() => {
            messageDiv.classList.add("hidden");
          }, duration);
        }

        resetGame() {
          // Reset local state and return to lobby screen
          this.selectedCards = [];
          this.drawnCard = null;
          this.selectedOpponentCard = -1;
          document.getElementById("gameOverlay").style.display = "none";
          document.getElementById("lobbyScreen").style.display = "flex";
          document.getElementById("gameTable").style.display = "none";
        }
      }

      // Instantiate the game client when page loads
      const gameClient = new DaVinciCodeClient();
    </script>
  </body>
</html>
